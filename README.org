# -*- org-confirm-babel-evaluate: nil -*-
#+TITLE: Hit

Hit is a library with a command line tool of a fill text search implementation.

* Table of Contents                                                     :TOC:
- [[#build][Build]]
- [[#library][Library]]
  - [[#initialize-index][Initialize Index]]
  - [[#add-documents][Add Documents]]
  - [[#search-documents][Search Documents]]
  - [[#delete-documents][Delete documents]]
- [[#cli][CLI]]
  - [[#install][Install]]
  - [[#usage][Usage]]

* Build

To build the project, run:

#+begin_src bash
  make
#+end_src

#+RESULTS:
| dune | test  |      |
| dune | build |      |
| dune | build | @doc |

* Library

To use the library in your own dune project, add the following to your ~dune~ file:
#+begin_src dune
  (libraries hit)
#+end_src

** Initialize Index

Create an index in your code:

#+begin_src ocaml :exports both :results silent
  #require "hit";;
  open Hit
  (* Create a storage implementation using the filesystem. The index will
     be located in the "my_index" directory *)
  module Storage = (val Io.file_storage "my_index" : Io.StorageInstance)
  (* Create an index module using the storage instance *)
  module Idx = Index.Make (Storage)
#+end_src

Initialize the index:

#+begin_src ocaml :exports both :results silent
  Idx.init ()
#+end_src

Load the index into the memory:

#+begin_src ocaml :exports both :results silent
  let index = Idx.load ()
#+end_src

** Add Documents

Add a document to the index:

#+begin_src ocaml :exports both :results silent
     let index = index
         |> Idx.add_doc (Document.from_source "local" "/documents/doc1.txt" "This is the content of document one.")
         |> Idx.add_doc (Document.from_source "local" "/documents/doc2.txt" "This is the content of document two.")
         |> Idx.add_doc (Document.from_source "local" "/documents/doc3.txt" "This is the content of document three.")
         |> Idx.add_doc (Document.from_source "local" "/documents/doc4.txt" "This is the very long content
                                                       Lorem ipsum dolor sit amet, consetetur sadipscing elitr,
                                                       sed diam nonumy eirmod tempor invidunt ut labore ets
                                                       dolore magna aliquyam erat, sed diam voluptua
                                                       of document four.")
#+end_src

~add_doc~ parses the document content and updates the index.
If you add a document with the same source and path again, the document
will be updated in the index if the content is different.
For example, let's update document two:

#+begin_src ocaml :exports both :results silent
    let index = index
        |> Idx.add_doc (Document.from_source "local" "/documents/doc1.txt" "This is the content of document one.")
        |> Idx.add_doc (Document.from_source "local" "/documents/doc2.txt" "This is the content of document II. Will be updated!")
#+end_src

Flush the changes to the storage:

#+begin_src ocaml :exports both :results silent
    Idx.flush index
#+end_src

** Search Documents

Search for documents containing a specific term:

#+begin_src ocaml :exports both :results pp
  #require "core";;
  open Core
  module Q = Index.Query.Make (Idx)
  let results = Q.find_docs [ "one"; "four" ] index;;
  List.iter ~f:(fun r -> Printf.printf "Found document: %s\n" (Index.QueryResult.doc_id r)) results
#+end_src

#+RESULTS:
: Found document: 27b3a15d450986a691a78be2276c5907
: Found document: 620e6c2c1fb0eaaabb6061f7daa5f98d
: - : unit = ()

There is also a query language that you can use to build more complex queries:

#+begin_src ocaml :exports both :results pp
  let results = Q.query (Index.Query.from_string "(or (and (eq four) (sw cont)) (ew ne))") index;;
  List.iter ~f:(fun r -> Printf.printf "Found document: %s\n" (Index.QueryResult.doc_id r)) results
#+end_src

#+RESULTS:
: Found document: 27b3a15d450986a691a78be2276c5907
: Found document: 620e6c2c1fb0eaaabb6061f7daa5f98d
: - : unit = ()

*** Preview Results

You can preview the content of the documents found in the search results:

#+begin_src ocaml :exports both :results pp
      let results = Q.find_docs [ "very"; "four" ] index in
      results
        |> List.map ~f:(fun r ->
                        (* A preview can be created with the document and the query result
                           The preview contains the Document text and highlights the matched tokens *)
      		        let doc = Idx.get_doc (Index.QueryResult.doc_id r) in
                        (* The preview can be shortened for a compact result view *)
                        (View.Preview.create doc r |> View.Preview.shorten))
#+end_src

#+RESULTS:
: *       - : Hit.View.Preview.part list list =
: [[Hit.View.Preview.Text "This is the "; Hit.View.Preview.Token "very";
:   Hit.View.Preview.Text " long content\n       ...         of document ";
:   Hit.View.Preview.Token "four"; Hit.View.Preview.Text "."]]

** Delete documents

It is also possible to delete documents by their id:

#+begin_src ocaml :exports both :results silent
  let index = Idx.delete_doc "27b3a15d450986a691a78be2276c5907" index;;
  Idx.flush index
#+end_src

Only the document is deleted. The index needs to be garbage collected to remove
the deleted documents from the storage:

#+begin_src ocaml :exports both :results silent
  let index = Idx.garbage_collect index
#+end_src

* CLI

** Install

To install the command line tool, copy the executable in your bin directory.
If you have ~$HOME/.opam/default/bin/hit~ in your path, simply run this:

#+begin_src bash
  make install
#+end_src

#+RESULTS:

** Usage

Initialize the index in a directory called ~my_index~:

#+begin_src bash
  hit init -d my_index
#+end_src

#+RESULTS:

Now let's add some documents:

#+begin_src bash :exports both :results pp
  hit import -d my_index -t ml lib 
#+end_src

#+RESULTS:
: doc-ff638bd4b2a382d7e515369f75fcdc79 lib/reference.ml
: doc-0e6ae644a708fec47caa0fb606f4fa38 lib/document.ml
: doc-52e568e6d5804c4ac58c3e440b0ce132 lib/text.ml
: doc-bc55196ca97dff26202a794bd3b557d5 lib/view.ml
: doc-2ad2ac6dc36c7d9b83b0592f4c76a74b lib/hit.ml
: doc-0c7b8d7b3eccee791bad3033834a8e97 lib/table.ml
: doc-26f07c4abe878a22b018f18f2bf7d34f lib/index.ml
: doc-3b33b96323b55de9ac4fd4f2de15052e lib/config.ml
: doc-1c33c093ad093a4c6d675e70efebd851 lib/io.ml

Let's search for the documents:

#+begin_src bash :exports both :results pp 
  hit search -d my_index -C none -m -c 3 content
#+end_src

#+RESULTS:
: doc-1c33c093ad093a4c6d675e70efebd851 lib/io.ml: open Table let read ... annel.close ic;     content   with exn ->     I ... w_symlinks:true f)) 
: doc-0e6ae644a708fec47caa0fb606f4fa38 lib/document.ml: open Sexplib.Std mo ... e m c = { meta = m; content = c } let from_sou ... Map = Map.Make (Id) 
: doc-52e568e6d5804c4ac58c3e440b0ce132 lib/text.ml: open Sexplib.Std mo ...  = tokens (Document.content doc) in     TokenMa ...  > List.map snd end 

Let's delete a document by its id:

#+begin_src bash :exports both :results pp 
  hit delete -d my_index doc-0e6ae644a708fec47caa0fb606f4fa38
#+end_src

#+RESULTS:

After deletions we need to garbage collect the index:

#+begin_src bash :exports both :results pp 
  hit gc -d my_index
#+end_src

#+RESULTS:
