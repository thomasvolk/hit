#+TITLE: Hit

Hit is a library with a command line tool of a fill text search implementation.

* Table of Contents                                                     :TOC:
- [[#build][Build]]
- [[#library][Library]]
- [[#cli][CLI]]
  - [[#install][Install]]
  - [[#usage][Usage]]

* Build

To build the project, run:

#+begin_src bash
  make
#+end_src

#+RESULTS:
| dune | test  |      |
| dune | build |      |
| dune | build | @doc |

* Library

To use the library in your own dune project, add the following to your `dune` file:
#+begin_src dune
  (libraries hit)
#+end_src

Create an index in your code:

#+begin_src ocaml :exports both :results silent
    open Hit
    (* Create a storage implementation using the filesystem. The index will
       be located in the "my_index" directory *)
    module Storage = (val Io.file_storage "my_index" : Io.StorageInstance)
    (* Create an index module using the storage instance *)
    module Idx = Index.Make (Storage)
#+end_src

Initialize the index:

#+begin_src ocaml :exports both :results silent
  Idx.init ()
#+end_src

Load the index nto the memory:

#+begin_src ocaml :exports both :results silent
  let index = Idx.load ()
#+end_src

Add a document to the index:

#+begin_src ocaml :exports both :results silent
  let d = Document.from_source "local" "/documents/doc1.txt" "This is the content of document one."
  let index' = Idx.add_doc d index
#+end_src

Flush the changes to the storage:

#+begin_src ocaml :exports both :results silent
  Idx.flush index'
#+end_src

Search for documents containing a specific term:

#+begin_src ocaml :exports both :results silent
  module Q = Index.Query.Make (Idx)
  let results = Q.find_docs ["one"] index'
#+end_src


* CLI

** Install

To install the command line tool, copy the executable in your bin directory:

#+begin_src bash
  cp -f _build/install/default/bin/hit ~/.bin
#+end_src

#+RESULTS:

** Usage

Initialize the index in a directory called `my_index`:

#+begin_src bash
  hit init -d my_index
#+end_src

#+RESULTS:

Now let's add some documents:

#+begin_src bash :exports both :results pp
  hit import -d my_index -t ml lib 
#+end_src

#+RESULTS:
: doc-ff638bd4b2a382d7e515369f75fcdc79 lib/reference.ml
: doc-0e6ae644a708fec47caa0fb606f4fa38 lib/document.ml
: doc-52e568e6d5804c4ac58c3e440b0ce132 lib/text.ml
: doc-bc55196ca97dff26202a794bd3b557d5 lib/view.ml
: doc-2ad2ac6dc36c7d9b83b0592f4c76a74b lib/hit.ml
: doc-0c7b8d7b3eccee791bad3033834a8e97 lib/table.ml
: doc-26f07c4abe878a22b018f18f2bf7d34f lib/index.ml
: doc-3b33b96323b55de9ac4fd4f2de15052e lib/config.ml
: doc-1c33c093ad093a4c6d675e70efebd851 lib/io.ml

Let's search for the documents:

#+begin_src bash :exports both :results pp 
  hit search -d my_index -C none -m -c 3 content
#+end_src

#+RESULTS:
: doc-1c33c093ad093a4c6d675e70efebd851 lib/io.ml: open Table let read ... annel.close ic;     content   with exn ->     I ... w_symlinks:true f)) 
: doc-0e6ae644a708fec47caa0fb606f4fa38 lib/document.ml: open Sexplib.Std mo ... e m c = { meta = m; content = c } let from_sou ... Map = Map.Make (Id) 
: doc-52e568e6d5804c4ac58c3e440b0ce132 lib/text.ml: open Sexplib.Std mo ...  = tokens (Document.content doc) in     TokenMa ...  > List.map snd end 

Let's delete a document by its id:

#+begin_src bash :exports both :results pp 
  hit delete -d my_index doc-0e6ae644a708fec47caa0fb606f4fa38
#+end_src

#+RESULTS:

After deletions we need to garbage collect the index:

#+begin_src bash :exports both :results pp 
  hit gc -d my_index
#+end_src

#+RESULTS:
